import * as _babel_traverse from '@babel/traverse';
import _babel_traverse__default, { Visitor as Visitor$1, NodePath, Scope, HubInterface } from '@babel/traverse';
export { NodePath, Scope, default as traverse } from '@babel/traverse';
import * as t from '@babel/types';
export { t as types };
import { SourceMapConverter } from 'convert-source-map';
import { Targets, InputTargets } from '@babel/helper-compilation-targets';
import gensync, { Handler } from 'gensync';
import { ParserOptions, File as File$1, tokTypes } from '@babel/parser';
export { tokTypes } from '@babel/parser';
import { GeneratorOptions, GeneratorResult } from '@babel/generator';
import template from '@babel/template';
export { default as template } from '@babel/template';

type ___CallerMetadata = CallerMetadata;
type ___ConfigItem<API> = ConfigItem<API>;
declare const ___ConfigItem: typeof ConfigItem;
declare const ___DEFAULT_EXTENSIONS: typeof DEFAULT_EXTENSIONS;
type ___File = File;
declare const ___File: typeof File;
type ___FileResult = FileResult;
type ___InputOptions = InputOptions;
declare const ___NodePath: typeof NodePath;
type ___PluginAPI = PluginAPI;
type ___PluginObject<S extends PluginPass = PluginPass> = PluginObject<S>;
type ___PluginPass<Options = object> = PluginPass<Options>;
declare const ___PluginPass: typeof PluginPass;
type ___PresetAPI = PresetAPI;
declare const ___Scope: typeof Scope;
type ___Visitor<S = unknown> = Visitor<S>;
declare const ___createConfigItem: typeof createConfigItem;
declare const ___createConfigItemAsync: typeof createConfigItemAsync;
declare const ___createConfigItemSync: typeof createConfigItemSync;
declare const ___getEnv: typeof getEnv;
declare const ___loadOptions: typeof loadOptions;
declare const ___loadOptionsAsync: typeof loadOptionsAsync;
declare const ___loadOptionsSync: typeof loadOptionsSync;
declare const ___loadPartialConfig: typeof loadPartialConfig;
declare const ___loadPartialConfigAsync: typeof loadPartialConfigAsync;
declare const ___loadPartialConfigSync: typeof loadPartialConfigSync;
declare const ___parse: typeof parse;
declare const ___parseAsync: typeof parseAsync;
declare const ___parseSync: typeof parseSync;
declare const ___resolvePlugin: typeof resolvePlugin;
declare const ___resolvePreset: typeof resolvePreset;
declare const ___template: typeof template;
declare const ___tokTypes: typeof tokTypes;
declare const ___transform: typeof transform;
declare const ___transformAsync: typeof transformAsync;
declare const ___transformFile: typeof transformFile;
declare const ___transformFileAsync: typeof transformFileAsync;
declare const ___transformFileSync: typeof transformFileSync;
declare const ___transformFromAst: typeof transformFromAst;
declare const ___transformFromAstAsync: typeof transformFromAstAsync;
declare const ___transformFromAstSync: typeof transformFromAstSync;
declare const ___transformSync: typeof transformSync;
declare const ___version: typeof version;
declare namespace __ {
  export { type ___CallerMetadata as CallerMetadata, ___ConfigItem as ConfigItem, ___DEFAULT_EXTENSIONS as DEFAULT_EXTENSIONS, ___File as File, type ___FileResult as FileResult, type ___InputOptions as InputOptions, ___NodePath as NodePath, type ___PluginAPI as PluginAPI, type ___PluginObject as PluginObject, ___PluginPass as PluginPass, type ___PresetAPI as PresetAPI, type ValidatedOptions as PresetObject, ___Scope as Scope, type ___Visitor as Visitor, export_default as buildExternalHelpers, ___createConfigItem as createConfigItem, ___createConfigItemAsync as createConfigItemAsync, ___createConfigItemSync as createConfigItemSync, ___getEnv as getEnv, ___loadOptions as loadOptions, ___loadOptionsAsync as loadOptionsAsync, ___loadOptionsSync as loadOptionsSync, ___loadPartialConfig as loadPartialConfig, ___loadPartialConfigAsync as loadPartialConfigAsync, ___loadPartialConfigSync as loadPartialConfigSync, ___parse as parse, ___parseAsync as parseAsync, ___parseSync as parseSync, ___resolvePlugin as resolvePlugin, ___resolvePreset as resolvePreset, ___template as template, ___tokTypes as tokTypes, ___transform as transform, ___transformAsync as transformAsync, ___transformFile as transformFile, ___transformFileAsync as transformFileAsync, ___transformFileSync as transformFileSync, ___transformFromAst as transformFromAst, ___transformFromAstAsync as transformFromAstAsync, ___transformFromAstSync as transformFromAstSync, ___transformSync as transformSync, _babel_traverse__default as traverse, t as types, ___version as version };
}

type SimpleCacheConfigurator = {
    (forever: boolean): void;
    <T>(handler: () => T): T;
    forever: () => void;
    never: () => void;
    using: <T>(handler: () => T) => T;
    invalidate: <T>(handler: () => T) => T;
};
type SimpleType = string | boolean | number | null | void | Promise<SimpleType>;

declare const __marker: unique symbol;
type ReadonlyDeepArray<T> = ReadonlyArray<T | ReadonlyDeepArray<T>> & {
    [__marker]: true;
};

/**
 * This file handles all logic for converting string-based configuration references into loaded objects.
 */

declare const resolvePlugin: (name: string, dirname: string, resolveESM: boolean) => string;
declare const resolvePreset: (name: string, dirname: string, resolveESM: boolean) => string;

type FileHandling = "transpile" | "ignored" | "unsupported";

type EnvFunction = {
    (): string;
    <T>(extractor: (babelEnv: string) => T): T;
    (envVar: string): boolean;
    (envVars: Array<string>): boolean;
};
type CallerFactory = {
    <T extends SimpleType>(extractor: (callerMetadata: CallerMetadata | undefined) => T): T;
    (extractor: (callerMetadata: CallerMetadata | undefined) => unknown): SimpleType;
};
type TargetsFunction = () => Targets;
type AssumptionFunction = (name: AssumptionName) => boolean | undefined;
type ConfigAPI = {
    version: string;
    cache: SimpleCacheConfigurator;
    env: EnvFunction;
    async: () => boolean;
    assertVersion: typeof assertVersion;
    caller?: CallerFactory;
};
type PresetAPI$1 = {
    targets: TargetsFunction;
    addExternalDependency: (ref: string) => void;
} & ConfigAPI;
type PluginAPI$1 = {
    assumption: AssumptionFunction;
} & PresetAPI$1;
declare function assertVersion(range: string | number): void;

interface UnloadedDescriptor<API, Options = object | undefined | false> {
    name: string | undefined;
    value: object | ((api: API, options: Options, dirname: string) => unknown);
    options: Options;
    dirname: string;
    alias: string;
    ownPass?: boolean;
    file?: {
        request: string;
        resolved: string;
    };
}

/**
 * Create a config item using the same value format used in Babel's config
 * files. Items returned from this function should be cached by the caller
 * ideally, as recreating the config item will mean re-resolving the item
 * and re-evaluating the plugin/preset function.
 */
declare function createConfigItem$1<API>(value: PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | void], { dirname, type, }?: {
    dirname?: string;
    type?: "preset" | "plugin";
}): Handler<ConfigItem<API>>;
declare const CONFIG_ITEM_BRAND: unique symbol;
/**
 * A public representation of a plugin/preset that will _eventually_ be load.
 * Users can use this to interact with the results of a loaded Babel
 * configuration.
 *
 * Any changes to public properties of this class should be considered a
 * breaking change to Babel's API.
 */
declare class ConfigItem<API> {
    /**
     * The private underlying descriptor that Babel actually cares about.
     * If you access this, you are a bad person.
     */
    _descriptor: UnloadedDescriptor<API>;
    /**
     * Used to detect ConfigItem instances from other Babel instances.
     */
    [CONFIG_ITEM_BRAND]: boolean;
    /**
     * The resolved value of the item itself.
     */
    value: object | Function;
    /**
     * The options, if any, that were passed to the item.
     * Mutating this will lead to undefined behavior.
     *
     * "false" means that this item has been disabled.
     */
    options: object | void | false;
    /**
     * The directory that the options for this item are relative to.
     */
    dirname: string;
    /**
     * Get the name of the plugin, if the user gave it one.
     */
    name: string | void;
    /**
     * Data about the file that the item was loaded from, if Babel knows it.
     */
    file: {
        request: string;
        resolved: string;
    } | void;
    constructor(descriptor: UnloadedDescriptor<API>);
}

type PluginObject<S extends PluginPass = PluginPass> = {
    name?: string;
    manipulateOptions?: (options: ValidatedOptions, parserOpts: ParserOptions) => void;
    pre?: (this: S, file: File) => void;
    post?: (this: S, file: File) => void;
    inherits?: (api: PluginAPI, options: unknown, dirname: string) => PluginObject;
    visitor?: Visitor$1<S>;
    parserOverride?: Function;
    generatorOverride?: Function;
};

declare class Plugin {
    key: string | undefined | null;
    manipulateOptions?: (options: unknown, parserOpts: unknown) => void;
    post?: PluginObject["post"];
    pre?: PluginObject["pre"];
    visitor: PluginObject["visitor"];
    parserOverride?: Function;
    generatorOverride?: Function;
    options: object;
    externalDependencies: ReadonlyDeepArray<string>;
    constructor(plugin: PluginObject, options: object, key?: string, externalDependencies?: ReadonlyDeepArray<string>);
}

type InputOptions = ValidatedOptions;
type ValidatedOptions = {
    cwd?: string;
    filename?: string;
    filenameRelative?: string;
    babelrc?: boolean;
    babelrcRoots?: BabelrcSearch;
    configFile?: ConfigFileSearch;
    root?: string;
    rootMode?: RootMode;
    code?: boolean;
    ast?: boolean;
    cloneInputAst?: boolean;
    inputSourceMap?: RootInputSourceMapOption;
    envName?: string;
    caller?: CallerMetadata;
    extends?: string;
    env?: EnvSet<ValidatedOptions>;
    ignore?: IgnoreList;
    only?: IgnoreList;
    overrides?: OverridesList;
    test?: ConfigApplicableTest;
    include?: ConfigApplicableTest;
    exclude?: ConfigApplicableTest;
    presets?: PluginList;
    plugins?: PluginList;
    passPerPreset?: boolean;
    assumptions?: {
        [name: string]: boolean;
    };
    targets?: TargetsListOrObject;
    browserslistConfigFile?: ConfigFileSearch;
    browserslistEnv?: string;
    retainLines?: boolean;
    comments?: boolean;
    shouldPrintComment?: Function;
    compact?: CompactOption;
    minified?: boolean;
    auxiliaryCommentBefore?: string;
    auxiliaryCommentAfter?: string;
    sourceType?: SourceTypeOption;
    wrapPluginVisitorMethod?: Function;
    highlightCode?: boolean;
    sourceMaps?: SourceMapsOption;
    sourceMap?: SourceMapsOption;
    sourceFileName?: string;
    sourceRoot?: string;
    parserOpts?: ParserOptions;
    generatorOpts?: GeneratorOptions;
};
type NormalizedOptions = {
    readonly targets: Targets;
} & Omit<ValidatedOptions, "targets">;
type CallerMetadata = {
    name: string;
};
type EnvSet<T> = {
    [x: string]: T;
};
type IgnoreItem = string | RegExp | ((path: string | undefined, context: {
    dirname: string;
    caller: CallerMetadata;
    envName: string;
}) => unknown);
type IgnoreList = ReadonlyArray<IgnoreItem>;
type PluginOptions = object | void | false;
type PluginTarget = string | object | Function;
type PluginItem = ConfigItem<PluginAPI$1> | Plugin | PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | void];
type PluginList = ReadonlyArray<PluginItem>;
type OverridesList = Array<ValidatedOptions>;
type ConfigApplicableTest = IgnoreItem | Array<IgnoreItem>;
type ConfigFileSearch = string | boolean;
type BabelrcSearch = boolean | IgnoreItem | IgnoreList;
type SourceMapsOption = boolean | "inline" | "both";
type SourceTypeOption = "module" | "script" | "unambiguous";
type CompactOption = boolean | "auto";
type RootInputSourceMapOption = object | boolean;
type RootMode = "root" | "upward" | "upward-optional";
type TargetsListOrObject = Targets | InputTargets | InputTargets["browsers"];
declare const knownAssumptions: readonly ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"];
type AssumptionName = (typeof knownAssumptions)[number];

type ResolvedConfig = {
    options: any;
    passes: PluginPasses;
    externalDependencies: ReadonlyDeepArray<string>;
};

type PluginPassList = Array<Plugin>;
type PluginPasses = Array<PluginPassList>;

type LoadPartialConfigOpts = {
    showIgnoredFiles?: boolean;
};
declare function loadPartialConfig$1(opts?: LoadPartialConfigOpts): Handler<PartialConfig | null>;

declare class PartialConfig {
    /**
     * These properties are public, so any changes to them should be considered
     * a breaking change to Babel's API.
     */
    options: NormalizedOptions;
    babelrc: string | void;
    babelignore: string | void;
    config: string | void;
    fileHandling: FileHandling;
    files: Set<string>;
    constructor(options: NormalizedOptions, babelrc: string | void, ignore: string | void, config: string | void, fileHandling: FileHandling, files: Set<string>);
    /**
     * Returns true if there is a config file in the filesystem for this config.
     */
    hasFilesystemConfig(): boolean;
}

type PluginAPI = PluginAPI$1 & typeof __;
type PresetAPI = PresetAPI$1 & typeof __;

declare const loadPartialConfigRunner: gensync.Gensync<[opts?: {
    showIgnoredFiles?: boolean;
}], PartialConfig, unknown>;
declare function loadPartialConfigAsync(...args: Parameters<typeof loadPartialConfigRunner.async>): Promise<PartialConfig>;
declare function loadPartialConfigSync(...args: Parameters<typeof loadPartialConfigRunner.sync>): PartialConfig;
declare function loadPartialConfig(opts: Parameters<typeof loadPartialConfig$1>[0], callback?: (err: Error, val: PartialConfig | null) => void): PartialConfig;
declare function loadOptionsImpl(opts: unknown): Handler<ResolvedConfig | null>;
declare const loadOptionsRunner: gensync.Gensync<[opts: unknown], ResolvedConfig, unknown>;
declare function loadOptionsAsync(...args: Parameters<typeof loadOptionsRunner.async>): Promise<ResolvedConfig>;
declare function loadOptionsSync(...args: Parameters<typeof loadOptionsRunner.sync>): ResolvedConfig;
declare function loadOptions(opts: Parameters<typeof loadOptionsImpl>[0], callback?: (err: Error, val: ResolvedConfig | null) => void): ResolvedConfig;
declare const createConfigItemRunner: gensync.Gensync<[value: PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | void], {
    dirname?: string;
    type?: "preset" | "plugin";
}?], ConfigItem<unknown>, unknown>;
declare function createConfigItemAsync(...args: Parameters<typeof createConfigItemRunner.async>): Promise<ConfigItem<unknown>>;
declare function createConfigItemSync(...args: Parameters<typeof createConfigItemRunner.sync>): ConfigItem<unknown>;
declare function createConfigItem(target: PluginTarget, options: Parameters<typeof createConfigItem$1>[1], callback?: (err: Error, val: ConfigItem<PluginAPI> | null) => void): ConfigItem<unknown>;

type NormalizedFile = {
    code: string;
    ast: t.File;
    inputMap: SourceMapConverter | null;
};

declare class File {
    _map: Map<unknown, unknown>;
    opts: {
        [key: string]: any;
    };
    declarations: {
        [key: string]: t.Identifier;
    };
    path: NodePath<t.Program>;
    ast: t.File;
    scope: Scope;
    metadata: {
        [key: string]: any;
    };
    code: string;
    inputMap: any;
    hub: HubInterface & {
        file: File;
    };
    constructor(options: any, { code, ast, inputMap }: NormalizedFile);
    /**
     * Provide backward-compatible access to the interpreter directive handling
     * in Babel 6.x. If you are writing a plugin for Babel 7.x, it would be
     * best to use 'program.interpreter' directly.
     */
    get shebang(): string;
    set shebang(value: string);
    set(key: unknown, val: unknown): void;
    get(key: unknown): any;
    has(key: unknown): boolean;
    /**
     * Check if a given helper is available in @babel/core's helper list.
     *
     * This _also_ allows you to pass a Babel version specifically. If the
     * helper exists, but was not available for the full given range, it will be
     * considered unavailable.
     */
    availableHelper(name: string, versionRange?: string | null): boolean;
    addHelper(name: string): t.Identifier;
    buildCodeFrameError(node: t.Node | undefined | null, msg: string, _Error?: typeof Error): Error;
}

declare class PluginPass<Options = object> {
    _map: Map<unknown, unknown>;
    key: string | undefined | null;
    file: File;
    opts: Partial<Options>;
    cwd: string;
    filename: string | void;
    constructor(file: File, key?: string | null, options?: Options);
    set(key: unknown, val: unknown): void;
    get(key: unknown): any;
    availableHelper(name: string, versionRange?: string | null): boolean;
    addHelper(name: string): t.Identifier;
    buildCodeFrameError(node: t.Node | undefined | null, msg: string, _Error?: typeof Error): Error;
}

declare function export_default(allowlist?: Array<string>, outputType?: "global" | "module" | "umd" | "var"): string;

declare function getEnv(defaultValue?: string): string;

type FileResultCallback = {
    (err: Error, file: null): void;
    (err: null, file: FileResult | null): void;
};
type FileResult = {
    metadata: {
        [key: string]: any;
    };
    options: {
        [key: string]: any;
    };
    ast: t.File | null;
    code: string | null;
    map: GeneratorResult["map"] | null;
    sourceType: "script" | "module";
    externalDependencies: Set<string>;
};

type Transform = {
    (code: string, callback: FileResultCallback): void;
    (code: string, opts: InputOptions | undefined | null, callback: FileResultCallback): void;
    (code: string, opts?: InputOptions | null): FileResult | null;
};
declare const transformRunner: gensync.Gensync<[code: string, opts?: ValidatedOptions], FileResult, unknown>;
declare const transform: Transform;
declare function transformSync(...args: Parameters<typeof transformRunner.sync>): FileResult;
declare function transformAsync(...args: Parameters<typeof transformRunner.async>): Promise<FileResult>;

declare const transformFileRunner: gensync.Gensync<[filename: string, opts?: ValidatedOptions], FileResult, unknown>;
declare function transformFile(filename: string, callback: FileResultCallback): void;
declare function transformFile(filename: string, opts: InputOptions | undefined | null, callback: FileResultCallback): void;
declare function transformFileSync(...args: Parameters<typeof transformFileRunner.sync>): FileResult;
declare function transformFileAsync(...args: Parameters<typeof transformFileRunner.async>): Promise<FileResult>;

type AstRoot = t.File | t.Program;
type TransformFromAst = {
    (ast: AstRoot, code: string, callback: FileResultCallback): void;
    (ast: AstRoot, code: string, opts: InputOptions | undefined | null, callback: FileResultCallback): void;
    (ast: AstRoot, code: string, opts?: InputOptions | null): FileResult | null;
};
declare const transformFromAstRunner: gensync.Gensync<[ast: AstRoot, code: string, opts: ValidatedOptions], FileResult, unknown>;
declare const transformFromAst: TransformFromAst;
declare function transformFromAstSync(...args: Parameters<typeof transformFromAstRunner.sync>): FileResult;
declare function transformFromAstAsync(...args: Parameters<typeof transformFromAstRunner.async>): Promise<FileResult>;

type FileParseCallback = {
    (err: Error, ast: null): void;
    (err: null, ast: File$1 | null): void;
};
type Parse = {
    (code: string, callback: FileParseCallback): void;
    (code: string, opts: InputOptions | undefined | null, callback: FileParseCallback): void;
    (code: string, opts?: InputOptions | null): File$1 | null;
};
declare const parseRunner: gensync.Gensync<[code: string, opts: ValidatedOptions], File$1, unknown>;
declare const parse: Parse;
declare function parseSync(...args: Parameters<typeof parseRunner.sync>): File$1;
declare function parseAsync(...args: Parameters<typeof parseRunner.async>): Promise<File$1>;

declare const version: string;

type Visitor<S = unknown> = _babel_traverse.Visitor<S>;

/**
 * Recommended set of compilable extensions. Not used in @babel/core directly, but meant as
 * as an easy source for tooling making use of @babel/core.
 */
declare const DEFAULT_EXTENSIONS: readonly [".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"];

export { type CallerMetadata, ConfigItem, DEFAULT_EXTENSIONS, File, type FileResult, type InputOptions, type PluginAPI, type PluginObject, PluginPass, type PresetAPI, type ValidatedOptions as PresetObject, type Visitor, export_default as buildExternalHelpers, createConfigItem, createConfigItemAsync, createConfigItemSync, getEnv, loadOptions, loadOptionsAsync, loadOptionsSync, loadPartialConfig, loadPartialConfigAsync, loadPartialConfigSync, parse, parseAsync, parseSync, resolvePlugin, resolvePreset, transform, transformAsync, transformFile, transformFileAsync, transformFileSync, transformFromAst, transformFromAstAsync, transformFromAstSync, transformSync, version };
