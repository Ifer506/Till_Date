{"version":3,"names":["Definition","PatternVisitor","OriginalPatternVisitor","Referencer","OriginalReferencer","Scope","ScopeManager","require","getKeys","fallback","visitorKeysMap","getVisitorValues","nodeType","client","FLOW_FLIPPED_ALIAS_KEYS","VISITOR_KEYS","getTypesInfo","flowFlippedAliasKeys","concat","Object","entries","reduce","acc","key","value","includes","propertyTypes","callProperties","type","values","indexers","properties","types","params","argument","elementType","qualification","rest","returnType","typeAnnotation","typeParameters","id","ArrayPattern","node","elements","forEach","visit","ObjectPattern","constructor","options","scopeManager","visitPattern","callback","_checkIdentifierOrVisit","left","processRightHandNodes","visitor","rightHandNodes","visitClass","_visitArray","decorators","typeParamScope","_nestTypeParamScope","_visitTypeAnnotation","implements","superTypeParameters","close","visitFunction","visitProperty","InterfaceDeclaration","_createScopeVariable","extends","body","TypeAlias","right","ClassProperty","_visitClassProperty","ClassPrivateProperty","PropertyDefinition","ClassPrivateMethod","MethodDefinition","DeclareModule","_visitDeclareX","DeclareFunction","DeclareVariable","DeclareClass","OptionalMemberExpression","MemberExpression","computed","__nestClassFieldInitializerScope","__nestScope","__currentScope","name","currentScope","variableScope","__define","parentScope","scope","j","length","bind","Array","isArray","visitorValues","i","visitorValue","propertyType","nodeProperty","k","loopPropertyNode","l","nodeList","module","exports","analyzeScope","ast","parserOptions","ignoreEval","optimistic","directive","nodejsScope","sourceType","ecmaFeatures","globalReturn","impliedStrict","ecmaVersion","childVisitorKeys","getVisitorKeys","referencer"],"sources":["../src/analyze-scope.cts"],"sourcesContent":["import type { Client } from \"./client.cts\";\n\nconst {\n  Definition,\n  PatternVisitor: OriginalPatternVisitor,\n  Referencer: OriginalReferencer,\n  Scope,\n  ScopeManager,\n} = (\n  process.env.BABEL_8_BREAKING\n    ? require(\"eslint-scope\")\n    : require(\"@nicolo-ribaudo/eslint-scope-5-internals\")\n) as import(\"./types.cts\").Scope;\nconst { getKeys: fallback } = require(\"eslint-visitor-keys\");\n\nlet visitorKeysMap: Record<string, string[]>;\nfunction getVisitorValues(nodeType: string, client: Client) {\n  if (visitorKeysMap) return visitorKeysMap[nodeType];\n\n  const { FLOW_FLIPPED_ALIAS_KEYS, VISITOR_KEYS } = client.getTypesInfo();\n\n  const flowFlippedAliasKeys = FLOW_FLIPPED_ALIAS_KEYS.concat([\n    \"ArrayPattern\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ]);\n\n  visitorKeysMap = Object.entries(VISITOR_KEYS).reduce((acc, [key, value]) => {\n    if (!flowFlippedAliasKeys.includes(value)) {\n      // @ts-expect-error FIXME: value is not assignable to type string[]\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n\n  return visitorKeysMap[nodeType];\n}\n\nconst propertyTypes = {\n  // loops\n  callProperties: { type: \"loop\", values: [\"value\"] },\n  indexers: { type: \"loop\", values: [\"key\", \"value\"] },\n  properties: { type: \"loop\", values: [\"argument\", \"value\"] },\n  types: { type: \"loop\" },\n  params: { type: \"loop\" },\n  // single property\n  argument: { type: \"single\" },\n  elementType: { type: \"single\" },\n  qualification: { type: \"single\" },\n  rest: { type: \"single\" },\n  returnType: { type: \"single\" },\n  // others\n  typeAnnotation: { type: \"typeAnnotation\" },\n  typeParameters: { type: \"typeParameters\" },\n  id: { type: \"id\" },\n};\n\nclass PatternVisitor extends OriginalPatternVisitor {\n  ArrayPattern(node: any) {\n    node.elements.forEach(this.visit, this);\n  }\n\n  ObjectPattern(node: any) {\n    node.properties.forEach(this.visit, this);\n  }\n}\n\nclass Referencer extends OriginalReferencer {\n  #client;\n\n  constructor(options: any, scopeManager: any, client: Client) {\n    super(options, scopeManager);\n    this.#client = client;\n  }\n\n  // inherits.\n  visitPattern(node: any, options: any, callback: any) {\n    if (!node) {\n      return;\n    }\n\n    // Visit type annotations.\n    this._checkIdentifierOrVisit(node.typeAnnotation);\n    if (node.type === \"AssignmentPattern\") {\n      this._checkIdentifierOrVisit(node.left.typeAnnotation);\n    }\n\n    // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.\n    if (typeof options === \"function\") {\n      callback = options;\n      options = { processRightHandNodes: false };\n    }\n\n    const visitor = new PatternVisitor(this.options, node, callback);\n    visitor.visit(node);\n\n    // Process the right hand nodes recursively.\n    if (options.processRightHandNodes) {\n      visitor.rightHandNodes.forEach(this.visit, this);\n    }\n  }\n\n  // inherits.\n  visitClass(node: any) {\n    // Decorators.\n    this._visitArray(node.decorators);\n\n    // Flow type parameters.\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow super types.\n    this._visitTypeAnnotation(node.implements);\n    this._visitTypeAnnotation(node.superTypeParameters?.params);\n\n    // Basic.\n    super.visitClass(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitFunction(node: any) {\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow return types.\n    this._checkIdentifierOrVisit(node.returnType);\n\n    // Basic.\n    super.visitFunction(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitProperty(node: any) {\n    if (node.value?.type === \"TypeCastExpression\") {\n      this._visitTypeAnnotation(node.value);\n    }\n    this._visitArray(node.decorators);\n    super.visitProperty(node);\n  }\n\n  InterfaceDeclaration(node: any) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // TODO: Handle mixins\n    this._visitArray(node.extends);\n    this.visit(node.body);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  TypeAlias(node: any) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    this.visit(node.right);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  ClassProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  ClassPrivateProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  PropertyDefinition(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  // TODO: Update to visit type annotations when TypeScript/Flow support this syntax.\n  ClassPrivateMethod(node: any) {\n    super.MethodDefinition(node);\n  }\n\n  DeclareModule(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareFunction(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareVariable(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareClass(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  // visit OptionalMemberExpression as a MemberExpression.\n  OptionalMemberExpression(node: any) {\n    super.MemberExpression(node);\n  }\n\n  _visitClassProperty(node: any) {\n    const { computed, key, typeAnnotation, decorators, value } = node;\n\n    this._visitArray(decorators);\n    if (computed) this.visit(key);\n    this._visitTypeAnnotation(typeAnnotation);\n\n    if (value) {\n      if (this.scopeManager.__nestClassFieldInitializerScope) {\n        this.scopeManager.__nestClassFieldInitializerScope(value);\n      } else {\n        // Given that ESLint 7 didn't have a \"class field initializer\" scope,\n        // we create a plain method scope. Semantics are the same.\n        this.scopeManager.__nestScope(\n          new Scope(\n            this.scopeManager,\n            \"function\",\n            this.scopeManager.__currentScope,\n            value,\n            true,\n          ),\n        );\n      }\n      this.visit(value);\n      this.close(value);\n    }\n  }\n\n  _visitDeclareX(node: any) {\n    if (node.id) {\n      this._createScopeVariable(node, node.id);\n    }\n\n    const typeParamScope = this._nestTypeParamScope(node);\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  _createScopeVariable(node: any, name: any) {\n    this.currentScope().variableScope.__define(\n      name,\n      new Definition(\"Variable\", name, node, null, null, null),\n    );\n  }\n\n  _nestTypeParamScope(node: any) {\n    if (!node.typeParameters) {\n      return null;\n    }\n\n    const parentScope = this.scopeManager.__currentScope;\n    const scope = new Scope(\n      this.scopeManager,\n      \"type-parameters\",\n      parentScope,\n      node,\n      false,\n    );\n\n    this.scopeManager.__nestScope(scope);\n    for (let j = 0; j < node.typeParameters.params.length; j++) {\n      const name = node.typeParameters.params[j];\n      scope.__define(name, new Definition(\"TypeParameter\", name, name));\n      if (name.typeAnnotation) {\n        this._checkIdentifierOrVisit(name);\n      }\n    }\n    scope.__define = parentScope.__define.bind(parentScope);\n\n    return scope;\n  }\n\n  _visitTypeAnnotation(node: any) {\n    if (!node) {\n      return;\n    }\n    if (Array.isArray(node)) {\n      node.forEach(this._visitTypeAnnotation, this);\n      return;\n    }\n\n    // get property to check (params, id, etc...)\n    const visitorValues = getVisitorValues(node.type, this.#client);\n    if (!visitorValues) {\n      return;\n    }\n\n    // can have multiple properties\n    for (let i = 0; i < visitorValues.length; i++) {\n      const visitorValue = visitorValues[i];\n      const propertyType = (propertyTypes as Record<string, any>)[visitorValue];\n      const nodeProperty = node[visitorValue];\n      // check if property or type is defined\n      if (propertyType == null || nodeProperty == null) {\n        continue;\n      }\n      if (propertyType.type === \"loop\") {\n        for (let j = 0; j < nodeProperty.length; j++) {\n          if (Array.isArray(propertyType.values)) {\n            for (let k = 0; k < propertyType.values.length; k++) {\n              const loopPropertyNode = nodeProperty[j][propertyType.values[k]];\n              if (loopPropertyNode) {\n                this._checkIdentifierOrVisit(loopPropertyNode);\n              }\n            }\n          } else {\n            this._checkIdentifierOrVisit(nodeProperty[j]);\n          }\n        }\n      } else if (propertyType.type === \"single\") {\n        this._checkIdentifierOrVisit(nodeProperty);\n      } else if (propertyType.type === \"typeAnnotation\") {\n        this._visitTypeAnnotation(node.typeAnnotation);\n      } else if (propertyType.type === \"typeParameters\") {\n        for (let l = 0; l < node.typeParameters.params.length; l++) {\n          this._checkIdentifierOrVisit(node.typeParameters.params[l]);\n        }\n      } else if (propertyType.type === \"id\") {\n        if (node.id.type === \"Identifier\") {\n          this._checkIdentifierOrVisit(node.id);\n        } else {\n          this._visitTypeAnnotation(node.id);\n        }\n      }\n    }\n  }\n\n  _checkIdentifierOrVisit(node: any) {\n    if (node?.typeAnnotation) {\n      this._visitTypeAnnotation(node.typeAnnotation);\n    } else if (node?.type === \"Identifier\") {\n      this.visit(node);\n    } else {\n      this._visitTypeAnnotation(node);\n    }\n  }\n\n  _visitArray(nodeList: any[]) {\n    if (nodeList) {\n      for (const node of nodeList) {\n        this.visit(node);\n      }\n    }\n  }\n}\n\nexport = function analyzeScope(ast: any, parserOptions: any, client: Client) {\n  const options = {\n    ignoreEval: true,\n    optimistic: false,\n    directive: false,\n    nodejsScope:\n      ast.sourceType === \"script\" &&\n      parserOptions.ecmaFeatures?.globalReturn === true,\n    impliedStrict: false,\n    sourceType: ast.sourceType,\n    ecmaVersion: parserOptions.ecmaVersion,\n    fallback,\n    childVisitorKeys: client.getVisitorKeys(),\n  };\n\n  const scopeManager = new ScopeManager(options);\n  const referencer = new Referencer(options, scopeManager, client);\n\n  referencer.visit(ast);\n\n  return scopeManager as any;\n};\n"],"mappings":"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","ignoreList":[]}